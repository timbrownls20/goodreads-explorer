# Implementation Plan: Analytics Dashboard

**Branch**: `002-analytics-dashboard` | **Date**: 2025-11-02 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/002-analytics-dashboard/spec.md`

**Note**: This template is filled in by the `/speckit.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

## Summary

Build a web-based analytics dashboard that visualizes Goodreads library data from the scraper feature (001-scrape-goodreads-library). The dashboard consists of a React frontend, Node.js/NestJS backend, and PostgreSQL database, deployed via Docker Compose. Users upload library data (multi-file JSON), which is stored in the database and queried for analytics. Supports filtering, real-time chart updates, and is designed for future multi-library support. Must handle up to 2000 books with sub-3-second load times and sub-500ms API responses.

**Technical Approach**:
- **Frontend**: React 18 + TypeScript SPA built with Vite, using react-chartjs-2 for visualizations
- **Backend**: Node.js 20+ with NestJS framework, serving RESTful API for file upload, data storage, and analytics queries
- **Database**: PostgreSQL 15+ with TypeORM for schema management and efficient analytics queries
- **Deployment**: Docker Compose orchestrating 3 containers (frontend, backend, database)

## Technical Context

**Frontend**:
- Language: TypeScript 5.x with React 18.x
- Build Tool: Vite 5.x (dev server, HMR, production build)
- UI Libraries: React 18.x, react-chartjs-2 (Chart.js wrapper)
- State Management: React hooks (useState, useEffect, useMemo)
- HTTP Client: Axios or fetch API for backend communication

**Backend**:
- Runtime: Node.js 20+ LTS
- Framework: NestJS 10+ (TypeScript-first, structured, enterprise-ready)
- ORM: TypeORM 0.3+ (PostgreSQL integration, migrations)
- Validation: class-validator + class-transformer (DTO validation)
- File Handling: Multer middleware for multipart file uploads
- API Docs: Swagger/OpenAPI (auto-generated by NestJS)

**Database**:
- RDBMS: PostgreSQL 15+
- Schema: Books table, Libraries table (for future multi-library), Users table (sessions)
- Indexes: On user_id, library_id, status, date_finished, rating for efficient filtering
- Migration Tool: TypeORM migrations (built-in CLI)

**Deployment**:
- Containerization: Docker + Docker Compose
- Frontend Container: Nginx serving built React app
- Backend Container: Node.js running NestJS app (production mode)
- Database Container: Official PostgreSQL image with persistent volume

**Testing**:
- Frontend: Vitest + React Testing Library (component tests)
- Backend: Jest (NestJS default) for unit/integration tests
- E2E: Manual testing with sample datasets (10, 500, 2000 books)
- Contract: OpenAPI/Swagger schema validation

**Target Platform**:
- Frontend: Modern browsers (Chrome 86+, Edge 86+, Firefox 78+, Safari 14+)
- Backend: Linux containers (Docker)
- Database: PostgreSQL 15+ compatible environment

**Performance Goals**:
- Initial page load: <2 seconds (frontend bundle + first API call)
- File upload & parse: 2000 books in <3 seconds (SC-001)
- Analytics API responses: <500ms (FR-029)
- Filter operations: <1 second end-to-end (frontend + backend, SC-004)

**Constraints**:
- Database must support 2000 books per library efficiently
- Backend API responses <500ms for good UX
- Frontend bundle size <500KB gzipped
- Docker containers must run on standard Linux host (2GB RAM minimum)
- No real-time websocket connections (REST API only for MVP)

**Scale/Scope**:
- 2000 books maximum capacity per library
- Single library per user (MVP); database schema supports multiple libraries
- 4 primary user stories (upload, summary stats, trends, filtering)
- Estimated 15-20 React components
- 8-10 NestJS API endpoints (controllers + services)
- 3-5 database tables (TypeORM entities)
- 8-12 data visualization widgets

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### I. Data-First Development: ✅ STRONG PASS
- **Evidence**: Spec defines clear entities with database-backed persistence
- **Plan**: data-model.md will formalize database schema (Books, Libraries, Users tables) with TypeORM entities
- **Database Schema**: PostgreSQL tables with proper relationships, constraints, and indexes
- **Migration Strategy**: TypeORM migrations for version-controlled schema changes

### II. CLI & Library Architecture: ✅ STRONG PASS
- **Status**: Backend API provides programmatic library interface; frontend provides visual UI
- **Evidence**: NestJS backend exposes RESTful API that can be consumed by:
  - Frontend React app (primary)
  - CLI tools (future: Node.js/TypeScript script to query analytics API)
  - Other programmatic clients (curl, scripts, integrations)
- **Library**: Backend analytics logic is modular, reusable TypeScript services separate from API controllers
- **Note**: Improves on original plan - API is inherently a "library interface" for data operations

### III. Test-Driven Development: ✅ PLANNED
- **Frontend Tests**: Vitest + React Testing Library for component behavior
- **Backend Tests**: Jest (NestJS default) for API endpoints, business logic, database operations
- **Test Data**: Generate synthetic datasets (10, 500, 2000 books) for performance testing
- **Contract Tests**: OpenAPI/Swagger schema validation (NestJS auto-generates via @nestjs/swagger)
- **Integration Tests**: End-to-end flows (upload → process → query → render)

### IV. Integration & Contract Testing: ✅ STRONG PASS
- **API Contracts**: OpenAPI/Swagger schema auto-generated by NestJS (@nestjs/swagger decorators)
  - `/api/library/upload` - File upload contract
  - `/api/analytics/summary` - Analytics response contract
  - `/api/analytics/filter` - Filter request/response contract
- **Database Contracts**: TypeORM entities define data contracts
- **External Contracts**: Scraper JSON format (from feature 001)
- **Validation**: class-validator DTOs validate requests/responses at API boundary

### V. Observability & Debuggability: ✅ STRONG PASS
- **Backend Logging**: Structured JSON logs (FR-027) to stdout (using winston or pino logger)
  - Request/response logging with trace IDs (NestJS interceptors)
  - Database query logging (TypeORM logger, SQL with execution time)
  - File processing progress (books parsed, errors, duration)
  - Error stack traces with context (NestJS exception filters)
- **Frontend Logging**: Console logging for errors, network failures
- **Monitoring**: Docker container logs accessible via `docker logs`
- **Debugging**: NestJS automatic Swagger UI at `/api/docs` for API testing

### VI. Data Quality & Validation: ✅ STRONG PASS
- **Backend Validation** (FR-026): class-validator DTOs validate all input
  - File upload: JSON format validation, file size limits (@IsNotEmpty, @MaxFileSize)
  - Book data: Required fields (title, author), type checking (@IsString, @IsEnum), enum validation
  - Filter params: Date ranges (@IsDate), rating bounds (@Min, @Max), status values (@IsEnum)
- **Database Constraints**: PostgreSQL + TypeORM enforces data integrity
  - NOT NULL constraints on required fields (via TypeORM @Column({ nullable: false }))
  - CHECK constraints on ratings (1-5), status enum (via TypeORM column types)
  - Foreign key constraints (books → libraries via @ManyToOne relationships)
- **Error Handling**: User-friendly API error responses with details (FR-025, NestJS exception filters)

### Constitution Compliance Summary

**Overall**: ✅ FULLY COMPLIANT (Architecture improves compliance vs. original plan)

| Principle | Status | Notes |
|-----------|--------|-------|
| I. Data-First | ✅ Strong Pass | Database schema, TypeORM entities, migrations |
| II. CLI & Library | ✅ Strong Pass | RESTful API = programmatic library interface |
| III. TDD | ✅ Planned | Jest (backend), Vitest (frontend), integration tests |
| IV. Integration/Contract | ✅ Strong Pass | OpenAPI contracts, class-validator DTOs, DB contracts |
| V. Observability | ✅ Strong Pass | Structured backend logs, API docs, container logs |
| VI. Data Quality | ✅ Strong Pass | class-validator DTOs, DB constraints, error handling |

**Improvement Over Original**: The backend architecture actually strengthens constitution compliance by providing:
1. API as reusable library interface (Principle II)
2. Stronger contracts via OpenAPI + class-validator DTOs (Principle IV)
3. Backend structured logging (Principle V)
4. Database-level validation (Principle VI)

## Project Structure

### Documentation (this feature)

```text
specs/002-analytics-dashboard/
├── spec.md              # Feature specification (complete)
├── plan.md              # This file (/speckit.plan output)
├── research.md          # Phase 0: Technology decisions & best practices
├── data-model.md        # Phase 1: Entity schemas & relationships
├── quickstart.md        # Phase 1: User guide for dashboard
├── contracts/           # Phase 1: Data contracts (JSON Schemas)
│   ├── library-dataset.schema.json
│   ├── filter-state.schema.json
│   └── localstorage-schema.json
├── checklists/          # Quality validation (existing)
│   └── requirements.md
└── tasks.md             # Phase 2: NOT created by /speckit.plan
```

### Source Code (repository root)

```text
dashboard/
├── docker-compose.yml       # Orchestration: frontend, backend, database
├── .env.example             # Environment variables template
├── README.md                # Setup and deployment instructions
│
├── frontend/                # React SPA
│   ├── Dockerfile           # Multi-stage build (Vite build → Nginx serve)
│   ├── package.json         # Node dependencies
│   ├── vite.config.ts       # Vite configuration
│   ├── tsconfig.json        # TypeScript configuration
│   ├── src/
│   │   ├── App.tsx          # Root component, routing
│   │   ├── main.tsx         # React entry point
│   │   ├── components/      # React components
│   │   │   ├── Dashboard.tsx      # Main dashboard layout
│   │   │   ├── UploadManager.tsx  # File upload UI
│   │   │   ├── FilterPanel.tsx    # Filter controls
│   │   │   ├── MetricCard.tsx     # Stat display component
│   │   │   └── charts/            # Chart components
│   │   │       ├── LineChart.tsx
│   │   │       ├── BarChart.tsx
│   │   │       └── PieChart.tsx
│   │   ├── services/        # API client layer
│   │   │   ├── api.ts       # Axios client setup
│   │   │   ├── library.ts   # Library upload API
│   │   │   └── analytics.ts # Analytics query API
│   │   ├── types/           # TypeScript interfaces
│   │   │   ├── Book.ts
│   │   │   ├── Filter.ts
│   │   │   └── Analytics.ts
│   │   ├── hooks/           # Custom React hooks
│   │   │   ├── useLibrary.ts
│   │   │   ├── useFilters.ts
│   │   │   └── useAnalytics.ts
│   │   └── utils/           # Helper functions
│   │       ├── dateFormat.ts
│   │       └── chartConfig.ts
│   └── tests/               # Vitest + React Testing Library
│       ├── components/
│       └── services/
│
├── backend/                 # NestJS server
│   ├── Dockerfile           # Node.js image with dependencies
│   ├── package.json         # Node dependencies
│   ├── tsconfig.json        # TypeScript configuration
│   ├── nest-cli.json        # NestJS CLI configuration
│   ├── src/
│   │   ├── main.ts          # NestJS app entry point
│   │   ├── app.module.ts    # Root application module
│   │   ├── config/          # Configuration module
│   │   │   └── database.config.ts  # TypeORM connection settings
│   │   ├── entities/        # TypeORM database entities
│   │   │   ├── book.entity.ts      # Book entity
│   │   │   ├── library.entity.ts   # Library entity
│   │   │   └── user.entity.ts      # User/session entity
│   │   ├── dto/             # Data Transfer Objects (class-validator)
│   │   │   ├── book.dto.ts         # CreateBookDto, BookResponseDto
│   │   │   ├── analytics.dto.ts    # AnalyticsSummaryDto, FilterRequestDto
│   │   │   └── upload.dto.ts       # UploadResponseDto
│   │   ├── controllers/     # API route handlers
│   │   │   ├── library.controller.ts   # POST /api/library/upload
│   │   │   ├── analytics.controller.ts # GET /api/analytics/*
│   │   │   └── health.controller.ts    # GET /api/health
│   │   ├── services/        # Business logic layer
│   │   │   ├── file-parser.service.ts    # JSON parsing & validation
│   │   │   ├── analytics-engine.service.ts # Stats calculation
│   │   │   └── database.service.ts       # DB operations
│   │   └── utils/           # Helpers
│   │       ├── logger.ts    # Winston/Pino structured logging
│   │       └── validators.ts # Custom validation decorators
│   ├── migrations/          # TypeORM database migrations
│   │   └── 1699000000000-InitialSchema.ts
│   └── test/                # Jest
│       ├── api/
│       ├── services/
│       └── entities/
│
├── database/                # PostgreSQL setup
│   ├── init.sql             # Initial schema (if not using TypeORM migrations)
│   └── seed_data/           # Sample datasets for testing
│       ├── small-10.json    # 10 books
│       ├── medium-500.json  # 500 books
│       └── large-2000.json  # 2000 books
│
└── scripts/                 # Development utilities
    ├── run-dev.sh           # Start all services locally
    ├── run-tests.sh         # Run all tests
    └── seed-db.sh           # Load test data
```

**Structure Decision**: Selected web application structure (fullstack). Separate `frontend/` and `backend/` directories with independent build processes, orchestrated by Docker Compose.

**Rationale**:
- **Frontend/Backend Separation**: Clear boundaries, independent deployment, different tech stacks
- **Docker-First**: Each service (frontend, backend, DB) is containerized for consistent environments
- **Modular Backend**: Follows FastAPI best practices (routers, services, models, schemas layers)
- **React Standards**: Component-based architecture with hooks, TypeScript for type safety
- **Testability**: Separate test directories for frontend (Vitest) and backend (pytest)
- **Future-Proof**: Database schema supports multi-library (future phase), backend API is extensible

## Complexity Tracking

**No violations identified**. The backend architecture actually strengthens constitution compliance compared to a client-only approach:

| Architectural Decision | Justification | Constitution Alignment |
|------------------------|---------------|------------------------|
| Backend API (FastAPI) | Provides programmatic library interface for analytics operations; enables future CLI tools to query data | ✅ Principle II: CLI & Library Architecture |
| Database (PostgreSQL) | Enables multi-library support (future), better data integrity, efficient querying | ✅ Principle I: Data-First Development |
| Docker Deployment | Consistent dev/prod environments, easy scaling, standard deployment pattern | ✅ Professional best practice |

**Simpler Alternative Considered**: Client-only JavaScript app with localStorage
**Rejected Because**:
- localStorage capacity limits (5-10MB) problematic for future multi-library support
- No programmatic API for integration (violates Principle II)
- Data validation only on client (weaker than database constraints)
- Harder to add features like user accounts, multi-library management later
